"use strict";function Cryptic(webCrypto,encoder,decoder){let cryptic={},crypto=webCrypto;"undefined"!=typeof window&&(crypto=window.crypto||webCrypto);let TextEncoder=encoder,TextDecoder=decoder;"undefined"!=typeof window&&(TextEncoder=window.TextEncoder,TextDecoder=window.TextDecoder);const toHex=cryptic.toHex=byteArray=>Array.from(new Uint8Array(byteArray)).map(val=>("0"+val.toString(16)).slice(-2)).join("");cryptic.fromHex=str=>{let result=new Uint8Array(str.match(/.{0,2}/g).map(val=>parseInt(val,16)));return result.slice(0,result.length-1)};const encode=cryptic.encode=byteArray=>btoa(Array.from(new Uint8Array(byteArray)).map(val=>String.fromCharCode(val)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,""),decode=cryptic.decode=str=>new Uint8Array(atob(str.replace(/\_/g,"/").replace(/\-/g,"+")).split("").map(val=>val.charCodeAt(0))),fromText=cryptic.fromText=string=>(new TextEncoder).encode(string),toText=cryptic.toText=byteArray=>(new TextDecoder).decode(byteArray);cryptic.combine=(a=[],b=[])=>{let A=a,B=b;"string"==typeof a&&(A=decode(a)),"string"==typeof b&&(B=decode(b));a=new Uint8Array(A),b=new Uint8Array(B);let c=new Uint8Array(a.length+b.length);return c.set(a),c.set(b,a.length),c};const random=cryptic.random=size=>crypto.getRandomValues(new Uint8Array(size));cryptic.createECDH=async(pub="P-256")=>{var key=await crypto.subtle.generateKey({name:"ECDH",namedCurve:pub},!0,["deriveBits"]),pub=await crypto.subtle.exportKey("spki",key.publicKey),key=encode(await crypto.subtle.exportKey("pkcs8",key.privateKey));return{pub:encode(pub),key:key}},cryptic.createECDSA=async(pub="P-256")=>{var key=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:pub},!0,["sign","verify"]),pub=await crypto.subtle.exportKey("spki",key.publicKey),key=encode(await crypto.subtle.exportKey("pkcs8",key.privateKey));return{pub:encode(pub),key:key}},cryptic.ecdsaSign=cryptic.sign=async(key,sig,signKey="P-256",hashAlg="SHA-256")=>{sig=sig.toString(),signKey=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDSA",namedCurve:signKey},!1,["sign"]),sig=await crypto.subtle.sign({name:"ECDSA",hash:hashAlg},signKey,fromText(sig));return encode(sig)},cryptic.ecdsaVerify=cryptic.verify=async(pub,sig,message,verifyKey="P-256",hashAlg="SHA-256")=>{message=message.toString(),verifyKey=await crypto.subtle.importKey("spki",decode(pub),{name:"ECDSA",namedCurve:verifyKey},!1,["verify"]);return await crypto.subtle.verify({name:"ECDSA",hash:hashAlg},verifyKey,decode(sig),fromText(message))},cryptic.hmacSign=async(hmacKey,sig,hashAlg="SHA-256")=>{sig=sig.toString(),hmacKey=await crypto.subtle.importKey("raw",hmacKey,{name:"HMAC",hash:hashAlg},!1,["sign"]),sig=await crypto.subtle.sign({name:"HMAC",hash:hashAlg},hmacKey,fromText(sig));return encode(sig)},cryptic.hmacVerify=async(verifyKey,sig,message,hashAlg="SHA-256")=>{message=message.toString(),verifyKey=await crypto.subtle.importKey("raw",verifyKey,{name:"HMAC",hash:hashAlg},!1,["verify"]);return await crypto.subtle.verify({name:"HMAC",hash:hashAlg},verifyKey,decode(sig),fromText(message))},cryptic.digest=async(digest,hashAlg="SHA-256")=>{digest=await crypto.subtle.digest({name:hashAlg},digest);return toHex(digest)};const pbkdf2=cryptic.pbkdf2=async(key,salt,iterations=1,result=256,hashAlg="SHA-256")=>{key=await crypto.subtle.importKey("raw",key,{name:"PBKDF2"},!1,["deriveBits"]),result=await crypto.subtle.deriveBits({name:"PBKDF2",salt:salt,iterations:iterations,hash:hashAlg},key,result);return encode(result)};cryptic.kdf=async(bits,salt,key,size,hashAlg="SHA-256")=>{key=await cryptic.hmacSign(bits,cryptic.toText(key));return await cryptic.pbkdf2(cryptic.decode(key),salt,1,size,hashAlg)},cryptic.ecdh=async(key,pubKey,privateKey="P-256",shared=256)=>{pubKey=await crypto.subtle.importKey("spki",decode(pubKey),{name:"ECDH",namedCurve:privateKey},!0,[]),privateKey=await crypto.subtle.importKey("pkcs8",decode(key),{name:"ECDH",namedCurve:privateKey},!0,["deriveBits"]),shared=await crypto.subtle.deriveBits({name:"ECDH",public:pubKey},privateKey,shared);return encode(shared)};const encrypt=cryptic.encrypt=async(cipher,iv,AD=null)=>{var key=await crypto.subtle.importKey("raw",iv,{name:"AES-GCM"},!1,["encrypt"]),iv=random(12),cipher=fromText(cipher),cipher=await crypto.subtle.encrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,cipher);return encode(iv)+"."+encode(cipher)},decrypt=cryptic.decrypt=async(decrypted="",iv,AD=null)=>{var key=await crypto.subtle.importKey("raw",iv,{name:"AES-GCM"},!1,["decrypt"]),iv=decode(decrypted.split(".")[0]),decrypted=decode(decrypted.split(".")[1]),decrypted=await crypto.subtle.decrypt({name:"AES-GCM",iv:iv,additionalData:AD||fromText("")},key,decrypted).catch(err=>{throw{message:"Failed to decrypt message.",error:err}});return toText(decrypted)};cryptic.passwordEncrypt=async(message,encrypted="",iterations=1e5)=>{var salt=random(32),encrypted=await pbkdf2(fromText(encrypted),salt,iterations,256),encrypted=await encrypt(message,decode(encrypted));return encode(fromText(iterations.toString()))+"."+encode(salt)+"."+encrypted},cryptic.passwordDecrypt=async(encrypted="",password="")=>{var keyBits=toText(decode(encrypted.split(".")[0])),salt=encrypted.split(".")[1],keyBits=await pbkdf2(fromText(password),decode(salt),keyBits,256),encrypted=encrypted.split(".").slice(2).join(".");return await decrypt(encrypted,decode(keyBits))};return cryptic}"undefined"!=typeof module&&module&&module.exports&&(module.exports=Cryptic);